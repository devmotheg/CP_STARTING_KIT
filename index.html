<!--!
  @author Mohamed Muntasir
  @link https://github.com/devmotheg
  -->

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="styles/styles.css" />
  <title>CP starting kit</title>
</head>

<body>
  <!-- Wrapper -->
  <div class="wrapper">
    <a href="https://github.com/devmotheg" target="_blank">Designed by Mohamed Muntasir</a>
    <!-- Content -->
    <div class="content">
      <!-- Header -->
      <header>
        <h1>Competitve Programming Starting Kit</h1>
        <a href="https://www.youtube.com/watch?v=bVKHRtafgPc&ab_channel=WilliamLin">William Lin's Introductory Video</a>
      </header>
      <!-- Main -->
      <main>
        <!-- Section 1 -->
        <section id="section-1">
          <h2>1) List of Blind 74 Leetcode Questions (Beginner Friendly)</h2>
          <!-- Arrays -->
          <div class="ds" id="array">
            <h3>Array</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/two-sum/">Two Sum</a></li>
              <li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell
                  Stock</a>
              </li>
              <li><a href="https://leetcode.com/problems/contains-duplicate/">Contains Duplicate</a></li>
              <li><a href="https://leetcode.com/problems/product-of-array-except-self/">Product of Array Except Self</a>
              </li>
              <li><a href="https://leetcode.com/problems/maximum-subarray/">Maximum Subarray</a></li>
              <li><a href="https://leetcode.com/problems/maximum-product-subarray/">Maximum Product Subarray</a></li>
              <li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated
                  Sorted Array</a></li>
              <li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Search in Rotated Sorted
                  Array</a>
              </li>
              <li><a href="https://leetcode.com/problems/3sum/">3 Sum</a></li>
              <li><a href="https://leetcode.com/problems/container-with-most-water/">Container With Most Water</a></li>
            </ul>
          </div>
          <!-- Binary -->
          <div class="ds" id="binary">
            <h3>Binary</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/sum-of-two-integers/">Sum of Two Integers</a></li>
              <li><a href="https://leetcode.com/problems/number-of-1-bits/">Number of 1 Bits</a></li>
              <li><a href="https://leetcode.com/problems/counting-bits/">Counting Bits</a></li>
              <li><a href="https://leetcode.com/problems/missing-number/">Missing Number</a></li>
              <li><a href="https://leetcode.com/problems/reverse-bits/">Reverse Bits</a></li>
            </ul>
          </div>
          <!-- Dynamic Programming -->
          <div class="ds" id="dynamic-programming">
            <h3>Dynamic Programming</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/climbing-stairs/">Climbing Stairs</a></li>
              <li><a href="https://leetcode.com/problems/coin-change/">Coin Change</a></li>
              <li><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest Increasing
                  Subsequence</a>
              </li>
              <li><a href="https://leetcode.com/problems/longest-common-subsequence/">Longest Common Subsequence</a>
              </li>
              <li><a href="https://leetcode.com/problems/word-break/">Word Break Problem</a></li>
              <li><a href="https://leetcode.com/problems/combination-sum-iv/">Combination Sum</a></li>
              <li><a href="https://leetcode.com/problems/house-robber/">House Robber</a></li>
              <li><a href="https://leetcode.com/problems/house-robber-ii/">House Robber II</a></li>
              <li><a href="https://leetcode.com/problems/decode-ways/">Decode Ways</a></li>
              <li><a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a></li>
              <li><a href="https://leetcode.com/problems/jump-game/">Jump Game</a></li>
            </ul>
          </div>
          <!-- Graphs -->
          <div class="ds" id="graph">
            <h3>Graph</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/clone-graph/">Clone Graph</a></li>
              <li><a href="https://leetcode.com/problems/course-schedule/">Course Schedule</a></li>
              <li><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/">Pacific Atlantic Water Flow</a>
              </li>
              <li><a href="https://leetcode.com/problems/number-of-islands/">Number of Islands</a></li>
              <li><a href="https://leetcode.com/problems/longest-consecutive-sequence/">Longest Consecutive Sequence</a>
              </li>
              <li><a href="https://leetcode.com/problems/alien-dictionary/">Alien Dictionary (Leetcode Premium)</a></li>
              <li><a href="https://leetcode.com/problems/graph-valid-tree/">Graph Valid Tree (Leetcode Premium)</a></li>
              <li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">Number
                  of Connected Components in an Undirected Graph
                  (Leetcode Premium)</a></li>
            </ul>
          </div>
          <!-- Intervals -->
          <div class="ds" id="interval">
            <h3>Interval</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/insert-interval/">Insert Interval</a></li>
              <li><a href="https://leetcode.com/problems/merge-intervals/">Merge Intervals</a></li>
              <li><a href="https://leetcode.com/problems/non-overlapping-intervals/">Non-overlapping Intervals</a></li>
              <li><a href="https://leetcode.com/problems/meeting-rooms/">Meeting Rooms (Leetcode Premium)</a></li>
              <li><a href="https://leetcode.com/problems/meeting-rooms-ii/">Meeting Rooms II (Leetcode Premium)</a></li>
            </ul>
          </div>
          <!-- Linked List -->
          <div class="ds" id="linked-list">
            <h3>Linked List</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/reverse-linked-list/">Reverse a Linked List</a></li>
              <li><a href="https://leetcode.com/problems/linked-list-cycle/">Detect Cycle in a Linked List</a></li>
              <li><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Merge Two Sorted Lists</a></li>
              <li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Merge K Sorted Lists</a></li>
              <li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End Of
                  List</a>
              </li>
              <li><a href="https://leetcode.com/problems/reorder-list/">Reorder List</a></li>
            </ul>
          </div>
          <!-- Matrix -->
          <div class="ds" id="matrix">
            <h3>Matrix</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/set-matrix-zeroes/">Set Matrix Zeroes</a></li>
              <li><a href="https://leetcode.com/problems/spiral-matrix/">Spiral Matrix</a></li>
              <li><a href="https://leetcode.com/problems/rotate-image/">Rotate Image</a></li>
              <li><a href="https://leetcode.com/problems/word-search/">Word Search</a></li>
            </ul>
          </div>
          <!-- String -->
          <div class="ds" id="string">
            <h3>String</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest
                  Substring Without Repeating Characters</a></li>
              <li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">Longest Repeating
                  Character Replacement</a></li>
              <li><a href="https://leetcode.com/problems/minimum-window-substring/">Minimum Window Substring</a></li>
              <li><a href="https://leetcode.com/problems/valid-anagram/">Valid Anagram</a></li>
              <li><a href="https://leetcode.com/problems/group-anagrams/">Group Anagrams</a></li>
              <li><a href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses</a></li>
              <li><a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a></li>
              <li><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic
                  Substring</a>
              </li>
              <li><a href="https://leetcode.com/problems/palindromic-substrings/">Palindromic Substrings</a></li>
              <li><a href="https://leetcode.com/problems/encode-and-decode-strings/">Encode and Decode Strings (Leetcode
                  Premium)</a></li>
            </ul>
          </div>
          <!-- Tree -->
          <div class="ds" id="tree">
            <h3>Tree</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree</a>
              </li>
              <li><a href="https://leetcode.com/problems/same-tree/">Same Tree</a></li>
              <li><a href="https://leetcode.com/problems/invert-binary-tree/">Invert/Flip Binary Tree</a></li>
              <li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">Binary Tree Maximum Path Sum</a>
              </li>
              <li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order
                  Traversal</a>
              </li>
              <li><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">Serialize and
                  Deserialize Binary Tree</a></li>
              <li><a href="https://leetcode.com/problems/subtree-of-another-tree/">Subtree of Another Tree</a></li>
              <li><a
                  href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct
                  Binary Tree from Preorder and Inorder
                  Traversal</a></li>
              <li><a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree</a>
              </li>
              <li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Kth Smallest Element in a
                  BST</a>
              </li>
              <li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest Common
                  Ancestor of BST</a></li>
              <li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a>
              </li>
              <li><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/">Add and Search
                  Word</a>
              </li>
              <li><a href="https://leetcode.com/problems/word-search-ii/">Word Search II</a></li>
            </ul>
          </div>
          <!-- Heap -->
          <div class="ds" id="heap">
            <h3>Heap</h3>
            <ul>
              <li><a href="https://leetcode.com/problems/top-k-frequent-elements/">Top K Frequent Elements</a></li>
              <li><a href="https://leetcode.com/problems/find-median-from-data-stream/">Find Median from Data Stream</a>
              </li>
            </ul>
          </div>
        </section>
        <!-- Section 2 -->
        <section id="section-2">
          <h2>2) 14 Patterns to Ace Any Coding Interview Question</h2>
          <!-- Sliding window -->
          <div id="sliding-window">
            <h3>1. Sliding Window</h3>
            <p>The Sliding Window pattern is&nbsp;used to perform a required
              operation on a specific window size of a given array or linked
              list, such as finding the longest subarray containing all
              1s.&nbsp;Sliding Windows start from the 1st element and keep
              shifting right by one element and adjust the length of the
              window according to the&nbsp;problem&nbsp;that you are solving.
              In some cases, the window size remains constant and in other
              cases the sizes grows or shrinks.</p>
            <img src="images/sliding-window.jpg" alt="" />
            <p><strong>Following&nbsp;are some ways you can identify that the given
                problem might require a sliding window:</strong></p>
            <ul>
              <li>The problem&nbsp;input is a linear data structure such as a
                linked list, array, or string</li>
              <li>You’re&nbsp;asked to find the
                longest/shortest&nbsp;substring, subarray, or a desired
                value</li>
            </ul>
            <p><strong>Common problems you use the sliding window pattern
                with:</strong></p>
            <ul>
              <li>Maximum&nbsp;sum&nbsp;subarray of size ‘K’&nbsp;(easy)</li>
              <li>Longest substring&nbsp;with ‘K’&nbsp;distinct&nbsp;characters
                (medium)</li>
              <li>String anagrams (hard)</li>
            </ul>
          </div>
          <!-- Two pointers -->
          <div id="two-pointers">
            <h3>2. Two Pointers or Iterators</h3>
            <p>Two Pointers is&nbsp;a pattern where two pointers iterate
              through the data structure in tandem until one or both of the
              pointers hit a certain condition. Two Pointers is often useful
              when searching pairs in a sorted array or linked list; for
              example, when you have to compare each element of an array to
              its other elements.</p>
            <p>Two pointers are needed because with just pointer, you would
              have to continually loop back through the array to find the
              answer. This back and forth&nbsp;with a single iterator is
              inefficient for time and space complexity — a concept referred
              to as asymptotic analysis.&nbsp;While the brute force or naive
              solution with 1 pointer would work, it will&nbsp;produce
              something along the lines of O(n²). In many cases, two pointers
              can help you find a solution with better space or&nbsp;runtime
              complexity.</p>
            <img src="images/2-pointers.jpg" alt="" />
            <p><strong>Ways to identify when to use the Two Pointer method:</strong></p>
            <ul>
              <li>It will feature problems where you deal with sorted arrays
                (or Linked Lists) and need to find a set of elements that
                fulfill certain constraints</li>
              <li>The set of elements in the array is a pair, a triplet, or
                even a subarray</li>
            </ul>
            <p><strong>Here are some problems that&nbsp;feature&nbsp;the Two Pointer
                pattern:</strong></p>
            <ul>
              <li>Squaring a sorted array (easy)</li>
              <li>Triplets that sum to zero (medium)</li>
              <li>Comparing strings that contain backspaces (medium)</li>
            </ul>
          </div>
          <!-- Fast and slow pointers -->
          <div id="fast-slow-pointers">
            <h3>3. Fast and Slow pointers</h3>
            <p>The Fast and Slow pointer approach, also known as
              the&nbsp;<strong>Hare &amp; Tortoise algorithm</strong>, is a
              pointer algorithm that uses two pointers which move through the
              array (or sequence/linked list)&nbsp;at different
              speeds.&nbsp;<strong>This approach is quite useful when dealing with cyclic linked
                lists or arrays.</strong></p>
            <p>By moving at different speeds (say, in a cyclic linked list),
              the algorithm proves that the two pointers are bound to meet.
              The fast pointer should catch the slow pointer once both the
              pointers are in a cyclic loop.</p>
            <img src="images/fast-slow-pointers.jpg" alt="" />
            <p><strong>How do you identify when to use the Fast and Slow
                pattern?</strong></p>
            <ul>
              <li>The problem will deal with a loop in a linked list or
                array</li>
              <li>When you need to know the position of a certain element or
                the overall length of the linked list</li>
            </ul>
            <p><strong>When should I use it over the Two Pointer method mentioned
                above?</strong></p>
            <ul>
              <li>There are some cases where you shouldn’t use the Two Pointer
                approach such as in a singly linked list where you can’t move
                in a backwards direction. An example of when to use the Fast
                and Slow pattern is when you’re trying to determine if a
                linked list is a palindrome</li>
            </ul>
            <p><strong>Problems featuring the fast and slow pointers
                pattern:</strong></p>
            <ul>
              <li>Linked List Cycle (easy)</li>
              <li>Palindrome Linked List&nbsp;(medium)</li>
              <li>Cycle in a Circular Array&nbsp;(hard)</li>
            </ul>
          </div>
          <!-- Merge intervals  -->
          <div id="merge-intervals">
            <h3>4. Merge Intervals</h3>
            <p>The Merge Intervals pattern is an efficient technique to deal
              with overlapping&nbsp;intervals. In a lot of problems involving
              intervals, you either need to find overlapping intervals or
              merge intervals if they overlap.
              <strong>The pattern works like this:</strong>
            </p>
            <p><strong>Given two intervals (‘a’ and ‘b’), there will be six
                different ways the two intervals can relate to each
                other:</strong></p>
            <img src="images/merge-intervals.png" alt="" />
            <p>Understanding and recognizing these six cases will help you
              help you solve a wide range of problems from inserting intervals
              to optimizing interval merges.</p>
            <p><strong>How do you identify when to use the Merge Intervals
                pattern?</strong></p>
            <ul>
              <li>If you’re asked to produce a list with only mutually
                exclusive intervals</li>
              <li>If you hear the term “overlapping intervals”</li>
            </ul>
            <p><strong>Merge interval problem patterns:</strong></p>
            <ul>
              <li>Intervals Intersection (medium)</li>
              <li>Maximum CPU Load (hard)</li>
            </ul>
          </div>
          <!-- Cyclic sort -->
          <div id="cyclic-sort">
            <h3>5. Cyclic sort</h3>
            <p>This pattern describes an interesting approach to deal with
              problems involving arrays containing numbers in a given
              range.&nbsp;The Cyclic Sort pattern iterates over the array one
              number at a time, and if the current number you are iterating is
              not at the correct index, you swap it with the number at its
              correct index.&nbsp;You could try placing the number in its
              correct index, but this will produce a complexity of O(n^2)
              which is not optimal, hence the Cyclic Sort pattern.</p>
            <img src="images/cyclic-sort.jpg" alt="" />
            <p><strong>How do I identify this pattern?</strong></p>
            <ul>
              <li>They will be problems involving a sorted array with numbers
                in a given range</li>
              <li>If the problem asks you to find the
                missing/duplicate/smallest number in an sorted/rotated
                array</li>
            </ul>
            <p><strong>Problems featuring cyclic sort pattern:</strong></p>
            <ul>
              <li>Find the Missing Number (easy)</li>
              <li>Find the Smallest Missing Positive Number&nbsp;(medium)</li>
            </ul>
          </div>
          <!-- In-place reversal of linked list -->
          <div id="in-place-reversal">
            <h3>6. In-place reversal of linked list</h3>
            <p>In a lot of problems, you may be asked to reverse the links
              between a set of nodes of a linked list. Often, the constraint
              is that you need to do this in-place, i.e., using the existing
              node objects and without using extra memory. This is where the
              above mentioned pattern is useful.</p>
            <p>This pattern reverses one node at a time starting with one
              variable (current) pointing to the head of the linked list, and
              one variable (previous) will point to the previous node that you
              have processed. In a lock-step manner, you will reverse the
              current node by pointing it to the previous before moving on to
              the next node. Also, you will update the variable “previous” to
              always point to the previous node that you have processed.</p>
            <img src="images/in-place-reversal.jpg" alt="" />
            <p><strong>How do I identify when to use this pattern:</strong></p>
            <ul>
              <li>If you’re asked to reverse a linked list without using extra
                memory</li>
            </ul>
            <p><strong>Problems featuring in-place reversal of linked list
                pattern:</strong></p>
            <ul>
              <li>Reverse a Sub-list (medium)</li>
              <li>Reverse every K-element Sub-list (medium)</li>
            </ul>
          </div>
          <!-- Tree BFS -->
          <div id="BFS">
            <h3>7. Tree BFS</h3>
            <p>This pattern is based on the Breadth First Search (BFS)
              technique to traverse a tree and uses a queue to keep track of
              all the nodes of a level before jumping onto the next level. Any
              problem involving the traversal of a tree in a level-by-level
              order can be efficiently solved using this approach.</p>
            <p>The Tree BFS pattern works by pushing the root node to the
              queue and then continually iterating until the queue is empty.
              For each iteration, we remove the node at the head of the queue
              and “visit” that node. After removing each node from the queue,
              we also insert all of its children into the queue.</p>
            <p><strong>How to identify the Tree BFS pattern:</strong></p>
            <ul>
              <li>If you’re asked to traverse a tree in a level-by-level
                fashion (or level order traversal)</li>
            </ul>
            <p><strong>Problems featuring Tree BFS pattern:</strong></p>
            <ul>
              <li>Binary Tree Level Order Traversal (easy)</li>
              <li>Zigzag Traversal (medium)</li>
            </ul>
          </div>
          <!-- Tree DFS  -->
          <div id="DFS">
            <h3>8. Tree DFS</h3>
            <p>Tree DFS is based on the Depth First Search (DFS) technique to
              traverse a tree.</p>
            <p>You can use recursion (or a stack for the iterative approach)
              to keep track of all the previous (parent) nodes while
              traversing.</p>
            <p><strong>The Tree DFS pattern works by starting at the root of the
                tree, if the node is not a leaf you need to do two
                things:</strong></p>
            <ol>
              <li>Decide whether to process the current node now (pre-order),
                or between processing two children (in-order) or after
                processing both children (post-order)</li>
              <li>Make two recursive calls for both the children of the current
                node to process them</li>
            </ol>
            <p><strong>How to identify the Tree DFS pattern:</strong></p>
            <ul>
              <li>If you’re asked to traverse a tree with in-order, preorder,
                or postorder DFS</li>
              <li>If the problem requires searching for something where the
                node is closer to a leaf</li>
            </ul>
            <p><strong>Problems featuring Tree DFS pattern:</strong></p>
            <ul>
              <li>Sum of Path Numbers (medium)</li>
              <li>All Paths for a Sum&nbsp;(medium)</li>
            </ul>
          </div>
          <!-- Two heaps -->
          <div id="two-heaps">
            <h3>9. Two heaps</h3>
            <p>In many problems, we are given a set of elements such that we
              can divide them into two parts. To solve the problem, we are
              interested in knowing the smallest element in one part and the
              biggest element in the other part. This pattern is an efficient
              approach to solve such problems.</p>
            <p>This pattern uses two heaps; A Min Heap to find the smallest
              element and a Max Heap to find the biggest element. The pattern
              works by storing the first half of numbers in a Max Heap, this
              is because you want to find the largest number in the first
              half. You then store the second half of numbers in a Min Heap,
              as you want to find the smallest number in the second
              half.&nbsp;At any time, the median of the current list of
              numbers can be calculated from the top element of the two
              heaps.</p>
            <p><strong>Ways to identify the Two Heaps pattern:</strong></p>
            <ul>
              <li>Useful in situations like Priority Queue, Scheduling</li>
              <li>If the problem states that you need to find the
                smallest/largest/median elements of a set</li>
              <li>Sometimes, useful in problems featuring a binary tree data
                structure</li>
            </ul>
            <p><strong>Problems featuring this pattern:</strong></p>
            <ul>
              <li>Find the Median of a Number Stream (medium)</li>
            </ul>
          </div>
          <!-- Subsets -->
          <div id="subsets">
            <h3>10. Subsets</h3>
            <p>A huge number of coding interview problems involve dealing with
              Permutations and Combinations of a given set of elements. The
              pattern Subsets describes an efficient Breadth First Search
              (BFS) approach to handle all these problems.</p>
            <p><strong>The pattern looks like this:</strong></p>
            <p>Given a set of [1, 5, 3]</p>
            <ol>
              <li>Start with an empty set: [[]]</li>
              <li>Add the first number (1) to all the existing subsets to
                create new subsets: [[], [1]];</li>
              <li>Add the second number (5) to all the existing subsets: [[],
                [1], [5], [1,5]];</li>
              <li>Add the third number (3) to all the existing subsets: [[],
                [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]</li>
            </ol>
            <p><strong>Here is a visual representation of the Subsets
                pattern:</strong></p>
            <img src="images/subsets.png" alt="" />
            <p><strong>How to identify the Subsets pattern:</strong></p>
            <ul>
              <li>Problems where you need to find the combinations or
                permutations of a given set</li>
            </ul>
            <p><strong>Problems featuring Subsets pattern:</strong></p>
            <ul>
              <li>Subsets With Duplicates (easy)</li>
              <li>String Permutations by changing case (medium)</li>
            </ul>
          </div>
          <!-- Modified binary search -->
          <div id="modified-binary-search">
            <h3>11. Modified binary search</h3>
            <p>Whenever you are given a sorted array, linked list, or matrix,
              and are asked to find a certain element, the best algorithm you
              can use is the Binary Search. This pattern describes an
              efficient way to handle all problems involving Binary Search.</p>
            <p><strong>The patterns looks like this for an ascending order
                set:</strong></p>
            <ol>
              <li>First, find the middle of start and end. An easy way to find
                the middle would be: middle = (start + end) / 2. But this has
                a good chance of producing an integer overflow so it’s
                recommended that you represent the middle as:&nbsp;middle =
                start + (end — start) / 2</li>
              <li>If the key is equal to the number at index middle then return
                middle</li>
              <li>If ‘key’ isn’t equal to the index middle:</li>
              <li>Check if key &lt; arr[middle]. If it is reduce your search to
                end = middle — 1</li>
              <li>Check if key &gt; arr[middle]. If it is reduce your search to
                end = middle + 1</li>
            </ol>
            <p><strong>Here is a visual representation of the Modified Binary Search
                pattern:</strong></p>
            <img src="images/modified-binary.png" alt="" />
            <p><strong>Problems featuring the Modified Binary Search
                pattern:</strong></p>
            <ul>
              <li>Order-agnostic Binary Search (easy)</li>
              <li>Search&nbsp;in a Sorted Infinite&nbsp;Array&nbsp;(medium)</li>
            </ul>
          </div>
          <!-- Top K elements -->
          <div id="top-k">
            <h3>12. Top K elements</h3>
            <p>Any problem that asks us to find the top/smallest/frequent ‘K’
              elements among a given set falls under this pattern.</p>
            <p>The best data structure to keep track of ‘K’ elements is Heap.
              This pattern will make use of the Heap to solve multiple
              problems dealing with ‘K’ elements at a time from a set of given
              elements.
              <strong>The pattern looks like this:</strong>
            </p>
            <ol>
              <li>Insert ‘K’ elements into the min-heap or max-heap based on
                the problem</li>
              <li>Iterate through the remaining numbers and if you find one
                that is larger than what you have in the heap, then remove
                that number and insert the larger one</li>
            </ol>
            <img src="images/k-elements.png" alt="" />
            <p>There is no need for a sorting algorithm because the heap will
              keep track of the elements for you.
            </p>
            <p><strong>How to identify the Top ‘K’ Elements pattern:</strong></p>
            <ul>
              <li>If you’re asked to find the top/smallest/frequent ‘K’
                elements of a given set</li>
              <li>If you’re asked to sort an array to find an exact element</li>
            </ul>
          </div>
          <!-- K-way merge -->
          <div id="k-merge">
            <h3>13. K-way Merge</h3>
            <p>K-way Merge helps you solve problems that involve a set of
              sorted arrays.</p>
            <p>Whenever you’re given ‘K’ sorted arrays, you can use a Heap to
              efficiently perform a sorted traversal of all the elements of
              all arrays. You can push the smallest element of each array in a
              Min Heap to get the overall minimum. After getting the overall
              minimum, push the next element from the same array to the heap.
              Then, repeat this process to make a sorted traversal of all
              elements.</p>
            <img src="images/k-way.png" alt="" />
            <p><strong>The pattern looks like this:</strong></p>
            <ol>
              <li>Insert the first element of each array in a Min Heap</li>
              <li>After this, take out the smallest (top) element from the heap
                and add it to the merged list</li>
              <li>After removing the smallest element from the heap, insert the
                next element of the same list into the heap</li>
              <li>Repeat steps 2 and 3 to populate the merged list in sorted
                order</li>
            </ol>
            <p><strong>How to identify the K-way&nbsp;Merge&nbsp;pattern:</strong></p>
            <ul>
              <li>The problem will feature sorted arrays, lists, or a
                matrix</li>
              <li>If the problem asks you to merge sorted lists, find the
                smallest element in a sorted list</li>
            </ul>
            <p><strong>Problems featuring the K-way Merge pattern:</strong></p>
            <ul>
              <li>Merge K Sorted Lists (medium)</li>
              <li>K Pairs with Largest Sums (Hard)</li>
            </ul>
          </div>
          <!-- Topological sort -->
          <div id="topological-sort">
            <h3>14. Topological sort</h3>
            <p>Topological Sort is used to find a linear ordering of elements
              that have dependencies on each other. For example, if event ‘B’
              is dependent on event ‘A’, ‘A’ comes before ‘B’ in topological
              ordering.</p>
            <p>This pattern defines an easy way to understand the technique
              for performing topological sorting of a set of elements.</p>
            <p><strong>The pattern works like this:</strong></p>
            <ol>
              <li>Initialization
                <ol type="i">
                  <li>Store the graph in adjacency lists by using a HashMap</li>
                  <li>To find all sources, use a HashMap to keep the count of
                    in-degreesBuild the graph and find in-degrees of all
                    vertices</li>
                </ol>
              </li>
              <li>Build the graph from the input and populate the in-degrees
                HashMap</li>
              <li>Find all sources
                <ol type="i">
                  <li>All vertices with ‘0’ in-degrees will be sources and are
                    stored in a Queue</li>
                </ol>
              </li>
              <li>Sort
                <ol type="a">
                  <li>For each source, do the following things:
                    <ol type="i">
                      <li>Add it to the sorted list</li>
                      <li>Get all of its children from the graph</li>
                      <li>Decrement the in-degree of each child by 1</li>
                      <li>If a child’s in-degree becomes ‘0’, add it to the
                        sources Queue</li>
                    </ol>
                  </li>
                  <li>Repeat (a), until the source Queue is empty</li>
                </ol>
              </li>
            </ol>
            <p><strong>How to identify the Topological Sort pattern:</strong></p>
            <ul>
              <li>The problem will deal with graphs that have no directed
                cycles</li>
              <li>If you’re asked to update all objects in a sorted order</li>
              <li>If you have a class of objects that follow a particular
                order</li>
            </ul>
            <p><strong>Problems featuring the Topological Sort pattern:</strong></p>
            <ul>
              <li>Task scheduling (medium)</li>
              <li>Minimum height of a tree (hard)</li>
            </ul>
          </div>
        </section>
      </main>
      <aside>
        <nav>
          <ul>
            <li><a href="#section-1" class="head">Q's</a></li>
            <li><a href="#array" class="skip">Array</a></li>
            <li><a href="#binary" class="skip">Binary</a></li>
            <li><a href="#dynamic-programming" class="skip">Dynamic Programming</a></li>
            <li><a href="#graph" class="skip">Graph</a></li>
            <li><a href="#interval" class="skip">Interval</a></li>
            <li><a href="#linked-list" class="skip">Linked List</a></li>
            <li><a href="#matrix" class="skip">Matrix</a></li>
            <li><a href="#string" class="skip">String</a></li>
            <li><a href="#tree" class="skip">Tree</a></li>
            <li><a href="#heap" class="skip">Heap</a></li>
            <li><a href="#section-2" class="head">P's</a></li>
            <li><a href="#sliding-window" class="skip">Sliding Window</a></li>
            <li><a href="#two-pointers" class="skip">Two Pointers</a></li>
            <li><a href="#fast-slow-pointers" class="skip">Fast & Slow pointers</a></li>
            <li><a href="#merge-intervals" class="skip">Merge Intervals</a></li>
            <li><a href="#cyclic-sort" class="skip">Cyclic sort</a></li>
            <li><a href="#in-place-reversal">In-place reversal linked list</a></li>
            <li><a href="#BFS" class="skip">Tree BFS</a></li>
            <li><a href="#DFS" class="skip">Tree DFS</a></li>
            <li><a href="#two-heaps" class="skip">Two heaps</a></li>
            <li><a href="#subsets" class="skip">Subsets</a></li>
            <li><a href="#modified-binary-search" class="skip">Modified binary search</a></li>
            <li><a href="#top-k" class="skip">Top K elements</a></li>
            <li><a href="#k-merge" class="skip">K-way Merge</a></li>
            <li><a href="#topological-sort" class="skip">Topological sort</a></li>
          </ul>
        </nav>
      </aside>
    </div>
  </div>
</body>

</html>